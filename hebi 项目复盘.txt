== hebi 项目复盘


前言:
1. 第一个接触到的完整dl项目. 需要处理的问题远比之前承接一个vimo兜不住的项目中的一个小模块复杂. 前后端交流和算法方案都踩了坑.


算法方案:

一、roi+single_bin组合+mask"近缺陷形态"部分

1. ROI切图
   hebi的图8192x8192, 图很大缺陷很小. 冗余的部分可粗糙剔除掉. 如果项目中发现还需要更精确的定位, 及时联系传统mo总那边. [模板匹配仿射变换之类的.]
2. 拆分单个物料
   一张图上多个物料, 最好选择把单个物料切出再送入模型.
   原因是: 缺陷检出这种项目, 客户需要定位到具体哪一块物料NG. 不做单物料切割检出的话, 也可在后处理时候根据缺陷坐标信息输出具体的单物料缺陷情况. 但和ROI目的一样,大图小缺陷, 时延限制下, 模型的输入尺寸不宜太大, 那么大图中的小缺陷可能被缩没了检不出. 所以在输入模型之前的预处理需要做精细些.
3. PSA的五孔部分在工位1234都不需要检出但五孔部分的形态"近视"缺陷. 可考虑将这些"形态"部分(传统算法)定位+mask掉; 甚至处理成ignore放进yaml.


二、 分割 or 分类粗定位

1. hebi的项目看下来, 能分割做的缺陷就还是直接走分割吧. 我们的售前和pm觉得可但他们不一定能稳住客户并保持客户不变卦. 尤其存在友商竞争的场景下, 客户看到别司做了, 很大概率就也会要求我们做精细定位. 答应的事直接打自己脸反悔..
2. 实在是不好标不好分割检出的缺陷(太小or太难界定和标注). 走分类方案检出, 我们需要尽量把这个小区域精确[此区域尽量不要存在物料之外的冗余, 面积尽可能做到的精确(也就是小)].


三、模型sdk对齐+时延+inference加速

1. seg sdk后处理
   针对分割项目, 我们需要较多的后处理才能得到可给客户展示的缺陷检出结果.【建议算法同学自行维护好一套sdk代码】, 一些pm or 售前 在项目过程中提出的新增小需求我们都可以在这里添加和维护[如置信度阈值开放, 缺陷个数, 长度, 面积过滤等..]. 维护sdk【方便我们跟工程同学对齐检出效果, 工程交出的模型和我们本地是有一致性的!】 分类模型只涉及一个置信度阈值可调, 后处理相对简单.

2. 时延
   算法出模型+工程封装+软件打包等, 这条链路上我们算法人员能和需要管辖的范围就是: 交给到工程同学的模型封装后, 耗时hold住. 所以在项目早期, 选定一个input_size来train模型的时候, 我们需要【向前端询问清楚】给到模型推理的时间大概有多少. [总CT时间减去一些如拍照通讯的时间,减去后处理时间等]. 对模型来说, input_size越大越容易得到好的检出精度, 但input_size越大时延则越长. 对算法同学来说, 出一个精度好时延又ok的模型是一个此消彼长的问题, 所以【可以给到模型的inference时间】这个信息一定要在项目早期明确.
  【工程同学添加时延log信息: 包括: 前处理(roi+切割物料啥的)时间 + model-inference时间 + seg的sdk后处理时间.】[以统一可搜索的方式整合这个Log]

3. inference加速
   1. 保证模型精度的前提下, 我们可以使用trt部署加速模型推理, 这个可以找工程同学执行【并对齐检出效果】[除非int8精度, float32,16工程都可搞无需算法动手, 我们传达这个部署方法即可]. hebi项目和changzhi对齐到的一个信息是:trt float16较之onnx部署可加速30%左右.
   2. 暴力法: 前线换显卡换好性能的cpu


前后端对齐:
   这是这个项目最糟心的地方, 主要是前端对齐. 需要和售前 or pm有"默契"
   1. 缺陷界定清楚
      这是很重要但暂时还不知道怎么去做好的一点. 现阶段我们的方法就是, 拉着pm+标注一起过pm整理好的缺陷文档, 一起理解一起迭代. 但项目过程中常出现缺陷形态被推翻, 缺陷形态好几种不同位置不同样式, 缺陷程度忽轻忽重但都要求检出, 的情况.
      [amp_train： batchsize可更大, 但可能train更耗时.]
      [zhige 迭代数据的方法: 20以下传回的漏杀数据, 20*重复倍数系数 + old_历史数据 = all_data. 出模型不会那么快, 因为要train全量的数据; 但是可以让模型看到历史数据里哪些部分不是缺陷, 可一定程度抑制过杀[类似把过杀数据标一下,告诉模型过杀的那些地方不是缺陷.].]
   2. 怎么传回有价值的数据?
      hebi项目过程中发现, 哪怕是老的售前也不知道【使用已部署到前线的模型测试缺陷料并传回过漏杀数据给到算法迭代】这个操作. 早期做了很久盲目传回维护数据的事儿.
      所以大致我们需要和前端有这些"默契":
         1. 使用已部署到前线的模型测试缺陷料并传回过漏杀数据给到算法迭代
         2. 集中 pk/跑线, 某or几 种缺陷的时候, 针对性传回这些缺陷数据, 无关数据不传回不迭代.
   3. 补充稀缺的缺陷数据
      拿不到足够多的缺陷料的时候,
      1. 麻烦前端去造: 单个物料上可, 高密度+丰富的缺陷等级+丰富的缺陷形态
      2. 【标注同学可以自己造, 用ps, junguang 跟我提过, 但这个方法靠谱否输入模型后是否造成缺陷学习混淆, 这个未知..】[ps应该是不大靠谱的.]
      3. zhangyao那边做数据融合+缺陷数据"自造". [蒋博: 图像渲染] [下周上半周的缺陷梳理下, 然后整合缺陷数据需求示例.]
   4. 前端怎么用好模型?
      对于新手pm, 可能需要"保姆式"教学怎么去Q or 跑线检出某些缺陷. 部署过去的模型可以调哪些阈值,调高or低之类的增强检出减少过杀 等.. [但很可能你教了ta还是没理解且还不细问...]
   5. 前端怎么定位+解决问题?
      【出现问题算法同学需要引导售前 or pm, 怎么逐步排查定位+解决】. 很多时候前端都忽略软件or工程人员, 直接都来找算法. 【仿佛算法同学就都是tpm,出问题了就找算法这个枢纽, 然后算法帮忙把问题伶清楚, 联系各方人员去排查和解决】
      但其实应该是: 软件崩溃得找软件和工程, 多数时候是因为前线硬件不给力和模型关系不大; 渲染显示需求找工程; 新增检出小需求(暴露阈值接口之类的)找算法和工程一起; 时延问题需软件和工程对齐清楚后再把具体问题抛给算法来优化.
   6. [所有人员定期开半小时左右的会议, 对齐"潜在"信息.]
      [项目约定周期例会, 会上不再由PM单一输出问题，前线的部署应用、FAE可以独立报出问题。PM负责对问题进行记录和跟踪]

结语:
    PSA+石墨的所有Qualify都结束了, 我这边昨天也汇总了所有数据从新针对工位1的缺陷训一个跑线模型[因为之前为了强行Q过过拟合了一些缺陷]. 后续希望顺利平稳优化精度迭代模型.

# 0416 复盘会议总结
1. 给到工程的脚本按照佳姐当前全流程来，后续脚本和模型给到前线，方便前线排查一致性问题
2. 数据反馈方式项目初期和PM约定好，避免后续修改标注需要和标注同学同步数据
3. 比较好的实践：mask掉有缺陷形态但又不要检出的部分
4. 把模型前处理、推理等集成到远哥meta库  变成一个部署库
5. 工程部署时在前处理、模型推理、后处理等关键节点增加时延log. [以统一可搜索的方式整合这个Log]
6. 项目约定周期例会，会上不再由PM单一输出问题，前线的部署应用、FAE可以独立报出问题。PM负责对问题进行记录和跟踪
[如果有新需求在会上提出，提出后明确责任人和交付到线上时间]
7. 标注群置顶信息:  数据更新的log；标注是否标注完成的log；  如何进行缺陷标注
8. 模型跟新和dll等在核心群维护置顶文件记录信息. [现在的新模型配上什么版本的dll用, 我们跟工程同学对好维护好, 再发出给前线]
